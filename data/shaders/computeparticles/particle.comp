#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

struct Particle
{
	vec2 pos;
	vec2 vel;
};

// Binding 0 : Particle storage buffer (read)
layout(std140, binding = 0) buffer ParticlesA
{
   Particle particlesA[ ];
};

// Binding 1 : Particle storage buffer (write)
layout(std140, binding = 1) buffer ParticlesB
{
   Particle particlesB[ ];
};

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 2) uniform UBO
{
	float deltaT; // TODO: change these next!
	float destX;
	float destY;
	int particleCount;
} ubo;
/*
vec2 attraction(vec2 pos, vec2 attractPos)
{
    vec2 delta = attractPos - pos;
	const float damp = 0.5;
    float dDampedDot = dot(delta, delta) + damp;
    float invDist = 1.0f / sqrt(dDampedDot);
    float invDistCubed = invDist*invDist*invDist;
    return delta * invDistCubed * 0.0035;
}

vec2 repulsion(vec2 pos, vec2 attractPos)
{
	vec2 delta = attractPos - pos;
	float targetDistance = sqrt(dot(delta, delta));
	return delta * (1.0 / (targetDistance * targetDistance * targetDistance)) * -0.000035;
}
*/
void main()
{
    // Current SSBO index
    uint index = gl_GlobalInvocationID.x;
	// Don't try to write beyond particle count
    if (index >= ubo.particleCount)
		return;

    // Read position and velocity
    vec2 vVel = particlesA[index].vel.xy;
    vec2 vPos = particlesA[index].pos.xy;

    // Move by velocity
    vPos += vVel * ubo.deltaT;

    // collide with boundary
    if ((vPos.x < -1.0) || (vPos.x > 1.0) || (vPos.y < -1.0) || (vPos.y > 1.0))
    	vVel = (-vVel * 0.1);
    else
    	particlesB[index].pos.xy = vPos;

    // Write back
    particlesA[index].vel.xy = vVel;
}
